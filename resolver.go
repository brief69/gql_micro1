package main

import (
	"context"
	"errors"
)

// THIS CODE IS AUTOGENERATED BY GQLGEN, DO NOT EDIT.

// Resolver connects individual resolvers with the data they need.
type Resolver struct{}

// QueryResolver is the resolver for the Query type.
type QueryResolver struct{ *Resolver }

// MutationResolver is the resolver for the Mutation type.
// Uncomment the following line if you have mutations in your schema.
// type MutationResolver struct{ *Resolver }

// SubscriptionResolver is the resolver for the Subscription type.
// Uncomment the following line if you have subscriptions in your schema.
// type SubscriptionResolver struct{ *Resolver }

// NewResolver creates a new Resolver that includes all subresolvers.
func NewResolver() *Resolver {
	return &Resolver{}
}

// NewQueryResolver creates a new QueryResolver.
func NewQueryResolver(r *Resolver) *QueryResolver {
	return &QueryResolver{r}
}

// NewMutationResolver creates a new MutationResolver.
// Uncomment the following function if you have mutations in your schema.
// func NewMutationResolver(r *Resolver) *MutationResolver {
// 	return &MutationResolver{r}
// }

// NewSubscriptionResolver creates a new SubscriptionResolver.
// Uncomment the following function if you have subscriptions in your schema.
// func NewSubscriptionResolver(r *Resolver) *SubscriptionResolver {
// 	return &SubscriptionResolver{r}
// }

// Query returns the resolver for the Query type.
func (r *Resolver) Query() QueryResolver {
	return QueryResolver{r}
}

// Mutation returns the resolver for the Mutation type.
// Uncomment the following line if you have mutations in your schema.
// func (r *Resolver) Mutation() MutationResolver {
// 	return MutationResolver{r}
// }

// Subscription returns the resolver for the Subscription type.
// Uncomment the following line if you have subscriptions in your schema.
// func (r *Resolver) Subscription() SubscriptionResolver {
// 	return SubscriptionResolver{r}
// }

// User resolves the user query by ID.
func (r *QueryResolver) User(ctx context.Context, id string) (*User, error) {
	// Here you would add your logic to fetch the user by their ID.
	// For example, you might fetch the user from a database.
	// This is just a placeholder implementation.
	if id == "1" {
		return &User{
			ID:    "1",
			Name:  "John Doe",
			Email: "john.doe@example.com",
		}, nil
	}
	return nil, errors.New("user not found")
}

// Add additional resolvers here for more complex queries, mutations, and subscriptions as needed.
